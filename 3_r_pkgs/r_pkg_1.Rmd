---
title: "R package creation"
author: ["Tobias & Nicolas", "cynkra GmbH"]
date: "February 22, 2022"
output:
  cynkradown::cynkra_slides:
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: true
fontsize: 10pt
lang: english
font: frutiger
wide: false
colorlinks: false
logo: true
header-includes:
  - \usepackage{parskip}
---

<style type="text/css">
.remark-code {
    font-size: 12px;
}
.font17 {
    font-size: 17px;
}
.font14 {
    font-size: 14px;
}
.remark-slide-number {
  display: inline;
  font-size: 15px;
}
</style>


```{r echo=FALSE,include=FALSE}
library(tidyverse)
library(kableExtra)
library(knitr)
library(rmarkdown)
```


# Introduction

Organization of half-day R courses:

- Intro courses:
  * Tidyverse intro I
  * Tidyverse intro II
  * Data visualization I
  * Data visualization II
- Advanced courses:
  * Advanced tidyverse
  * R package creation (this course)
  * Working with database systems
  * Parallelization & efficient R programming
  * Advanced topics (tbd)

???

<!-- Antoine and I would like to welcome you on behalf of Cynkra. In the coming weeks we will be organizing two sets or R courses, split up as introductory and advanced. Each course will be half a day and the advanced courses are held twice in succession. Today we're starting with a first tidyverse intro course. -->

---

# Dates

- Week 1, Jan 25: Tidyverse intro I (Antoine)
- Week 2, Feb 1: Tidyverse intro II + Adv. Tidyverse (Antoine)
- Week 3, Feb 8: Adv. Tidyverse (Antoine)
- Week 4, Feb 15: R-pkg creation (Tobias)
- Week 5, Feb 22: R-pkg creation (Tobias), Feb 24: Data vis. & ggplot2 I (Antoine)
- Week 6, Mar 1: Data vis. & ggplot2 II (Antoine) + Parallelization (Patrick)
- Week 7, Mar 8: Parallelization (Patrick)
- Week 8, Mar 15: Databases (Kirill)
- Week 9, Mar 22: Databases (Kirill)
- Week 10, Mar 29: TBD (Antoine)
- Week 11, April 5: TBD (Antoine)

???
<!-- Courses are typically held on Tuesdays, with the exception of the first intro course on data visualization. Intro courses are in the mornings, while advanced courses take place on afternoons. We initially were hoping to be able to carry out these courses with physical presence, but at least for now, this is not possible. Hopefully, this will change over the course of the next weeks to months. For each course, two people representing Cynkra will be available, a topic-specific expert, as well as myself in a coordinating role. -->

---

# Course material

Our course material currently is available from a Github repository at

https://github.com/cynkra/bag-courses

![how to download](cynkra-repo-dl.png)

???
<!-- If anyone has issues accessing this material, let us know, it's important to us that you have the code available to experiment with. -->

---

# General remarks

- We are happy to be able to do the courses in a semi-remote fashion now. For those who are attending remotely, don't hesitate to interrupt up or write into the chat if anything is uncler or you have questions.
- If we feel that some questions are holding back the course, we will defer answering to the next break.
- We were asked to provide recordings of the courses for those of you who cannot join, so recording is activated.
- Per course unit, we offer 4 hours of follow up time; approach us with questions (nicolas@cynkra.com)!

???
<!-- We're not only here to tell you some new and interesting things about R, but we'd also like to help you apply that knowledge to actual scenarios you're dealing with. So in this course follow up time, we're happy to help you with questions you might have regarding course material. But we would like to also offer our help with questions that come up when applying R to your day to day tasks. If you have a question you'd like to discuss, write us an email and we will schedule a meeting. -->

---

# R package creation

.font17[
Overview:

1. Intro
1. How to start?
1. Documentation
1. Dependencies (DESCRIPTION) & NAMESPACE
1. Useful little helpers: `{usethis}`
1. Classes
1. Unit testing
1. Errors and warnings
1. Versioning
1. Continuous Integration
1. Best practices
1. Further reading
]

---

# Intro: Advantages of R packages over R scripts

.font17[
- Best case: Package provides function(s) for working on re-occurring tasks
- function as single source of truth (optimized implementation, higher chance of being bug-free)
- sometimes related tasks can be solved by one function by introducing an argument
- arguments, behaviour and result can be well documented (cf. later)
- functions can be tested (cf. later)
- there is some pressure to properly document functions (R CMD check)
- can be shared easily
]

---

# Intro: Advantages of R scripts over R packages

- Package is less flexible (but can be extended)
- Tasks for which script is preferrable: 
    1. "Quickly checking something, but should be reproducible"
    1. Data exploration
    1. Report creation (function to create report could also be part of a package though)

---

# Intro: R scripts vs. R packages

Summary:
- R package provides functionality; contains functions (and/or data)
- R script tries solving a certain, rather specific task at hand <-> R packages provide the tools

<!-- # FIXME: some more content? -->

---

# How to start?

In order for RStudio to recognize a project as a package, it needs:
File `DESCRIPTION`, which contains:
- package name as it will be called by e.g. `library()`
- authors, etc.
- dependencies on other packages
- etc.

If this file is there:
- a `Build`-pane is available in RStudio (restart may be necessary)
- the package can be installed to the library

---

# How to start?

Further components:
- File "NAMESPACE" containing information about imported and exported functions (more see below)
- Directory "R/", containing the files with the function definitions
- Directory "man/", containing the Rd-files with the documentation of the package's functions

---

# How to start?

There are 2 obvious and easy ways of creating a new valid package in R/RStudio in no time:
1. Using RStudio functionality:  
                `Create a project` -> 
                `New Directory` (or existing empty one) ->  
                `R Package` ->
                fill out mask ->
                `Create package`
2. Using {usethis}: `usethis::create_package("path/to/package")`

.remark-code[Attention: Naming rule for R packages (CRAN rule):
  - only letters (lower- or uppercase), numbers and "." (no "-" or "_")
  - start with a letter
  - can't end with a "."]

---

# Exercise

- Create an R package (or 2) in one of the shown ways.
- Examine the files/directories that were created.
- Build the package (Ctrl+Shift+B)

---

# Documentation

Can be found in the `Rd`-files in directory `man/`.

Example:
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{hello}
\alias{hello}
\title{Title}
\usage{
hello()
}
\value{
Prints "Hello, World!" in green.
}
\description{
Title
}
\examples{
hello()
}
```

---

# Documentation

Use `{roxygen2}` for automating the documentation process as much as possible.

Example:
```{r eval=FALSE}
#' Title
#'
#' @return Prints "Hello, World!" in green.
#' @export
#'
#' @examples
#' hello()
hello <- function() {
  cat(crayon::green("Hello, World!"))
}
```


---

# Documentation

These specially formatted comments will be translated and written to respective `Rd`-file when calling `devtools::document()` or keyboard shortcut `Ctrl+Shift+D`.

An exhaustive intro to documentation can be found here:
- General info and vignettes on subtopics: https://roxygen2.r-lib.org/index.html
- Workflow/general best practices: https://r-pkgs.org/man.html

---

# Documentation

The documentation of a function consists of:
.font17[
```{r echo=FALSE,out.width=='70%'}
tibble::tribble(
  ~Field, ~Tag, ~Info,
  "Header", "", "Description in a few words",
  "Description", "@description", "Description in one or two short sentences",
  "Usage", "", "Is added automatically by {roxygen2}/'devtools::document()'",
  "Arguments", "@param/@inheritParams", "Requirements for the arguments",
  "Details", "@details", "Additional useful info for the user",
  "Value", "@return", "What is the output of the function?",
  "...", "...", "Others: see references"
) %>% 
  knitr::kable()
```
]

---

# Documentation

.font17[
Important: In order to make a function available to users loading the package, there needs to be a tag `@export`.

Usually only exported functions are documented in that detailed manner.

It helps to add commentary to internal functions too though.

All non-exported (so-called internal) functions are available for all other internal or exported functions of the package.
They are available in the console as well after calling `devtools::load_all()` while working on the package.
They can be individually referred to as well by `<your.package>:::<internal_function>()`.
]

---

# Exercise (~10min)

.font17[
- Make up a function (does not have to be particularly useful) with at least one argument and save its implementation in a file in the directory `R/` of your new package.
- Add documentation to the function (tip: `Code` -> `Insert Roxygen Skeleton` while cursor in the function definition block; or `Ctrl+Alt+Shift+R`, if you manage)
- Make sure the function will be exported
- Make sure the associated `Rd`-file exists and is filled according to your documentation
- "Build" your package using the `Build` pane, `devtools::build()` or `Ctrl+Shift+B` and use the function

One more tip: in general it can be helpful to "cheat" by checking out how the documentation is done in packages on GitHub that have a documentation feature you would like for your own package.
]

---

# Dependencies (DESCRIPTION) & NAMESPACE

If you need another package's function(s), you should ask yourself, if these functions are needed for base functionality of your package, or if it's just e.g. for testing, building vignettes etc., that this package is necessary.

In the former case, the package will be listed under "`Imports:`" in "DESCRIPTION", in the latter case under "`Suggests:`".
The consequence is, that when installing your package, packages under "`Imports:`" are installed as well, whereas the other packages are not.

---

# Dependencies (DESCRIPTION) & NAMESPACE

.font17[
There is an even stronger statement available for defining dependencies in "DESCRIPTION": "`Depends:`".
If a package is listed here, this package's namespace is always attached to the search path whenever your package is, i.e. you can use its functions without the need of `::()` after calling `library("<your.package>")`.

Using "`Depends:`" is generally not recommended, since this can potentially lead to namespace conflicts.
In some cases (e.g. one package building on another one and only making sense in context with it) it should be used though.

Tip: Use `usethis::use_package()` to add package dependencies, argument `type` can be one of "Imports", "Suggests", "Depends".
]

---

# Dependencies (DESCRIPTION) & NAMESPACE

.font17[
If you use `Imports:` you will have to use the `::()` notation inside your package's code.

If you rely on the other package's function(s) heavily, there is the option of creating a file "R/import.R" (name is just convention), in which you can further influence your "NAMESPACE" file.
This file will have entries that look roughly like this:
```{r eval=FALSE}
#' @import cli
#' @importFrom glue glue
#' @importFrom vctrs vec_names vec_as_names vec_cbind vec_rbind vec_recycle
#' @import dplyr
#' @rawNamespace import(tidyr, except = c(extract))
NULL
```

When calling `devtools::document()`, these lines affect "NAMESPACE".
The functions imported like this can be used internally without the need for `::()`.
They can NOT be used by the end user calling `library("<your.package>")` though.
]

---

# Dependencies (DESCRIPTION) & NAMESPACE

.font17[
A way to make such functions available after `library("<your.package>")` is to reexport them.
For this, create a file "R/reexport.R" (name is just convention) and add entries like e.g.:
```{R eval=FALSE}
#' @export
magrittr::`%>%`

#' @export
dplyr::filter
```
After `devtools::document()` they will make an appearance in "NAMESPACE".
]

---

# Dependencies (DESCRIPTION) & NAMESPACE

When using `devtools::document()` together with {roxygen2}-style documentation, the file "NAMESPACE" mentioned above is written automatically based solely on the content in "R/" (not affected by DESCRIPTION).

It contains entries of the sort:
```
S3method(print,new_class)
export(hello)
import(crayon)
```

It's basically a list of all objects (functions/methods or packages) that are imported, registered or exported by your package.

---

# Dependencies (DESCRIPTION) & NAMESPACE

.font17[
What actually happens when calling `library("<your.package>")`?

`library()` is a rather complex function, but 2 important steps are:
1. Loading the namespace into an internal database (`loadNamespace()`; usually only useful in internal R-Code)
1. Attaching the namespace to the search path (`attachNamespace()`; it's being inserted in the beginning right after `.GlobalEnv`):

Now, when calling a function without `::()`, first the `.GlobalEnv` is being searched for a function with that name, and in case it isn't found, the search path is checked for such a function. The first hit is being used (-> can lead to conflicts).

The current search path can be checked with `search()`.

For checking if a package is available it's recommended to use `requireNamespace("x", quietly = TRUE)`. This function will return `FALSE` if the package "x" is not available and won't throw an error.
]

---

# Dependencies (DESCRIPTION) & NAMESPACE

.font17[
In some cases it can be useful/necessary to call a function upon loading or attaching your package.
This can be done with the - non-exported - functions `.onLoad(libname, pkgname)` or `.onAttach(libname, pkgname)`.

By convention these functions would live in "R/zzz.R".

**.onAttach(libname, pkgname)**

If you want to inform the user of the package about something, use `.onAttach()` and write a message using `packageStartupMessage()`: that way the message can be suppressed selectively using `suppressPackageStartupMessages()`.
```{r eval=FALSE}
.onAttach <- function(libname, pkgname) {
  packageStartupMessage("Welcome to my package")
}
```

**.onLoad(libname, pkgname)**

For pretty much all other purposes use `.onLoad()`, e.g. for setting customs options for your package (e.g. based on system conditions).
]

---

# Exercise (5-10min)

- Make all {dplyr}-functions available without `::()` after "loading" (i.e. here: "attaching") your package.
- Make only `dplyr::select()` available after "loading" your package.

---

# Useful little helpers: `{usethis}`

We have already encountered a few functions from the package {devtools} (`document()`, `load_all()`, `build()`) that help with package development.

Another package that has the same goal is {usethis} (https://usethis.r-lib.org/).
It is full of helper functions that facilitate package creation. We already encountered `usethis::create_package()`.

---

# `{usethis}`

.font17[
Here a small subset of the services it provides:
- `use_git()` -> initialises a git repository
- `use_mit_license()` -> adds MIT (permissive) license to your package
- `use_github()` -> takes a local project to GitHub ("private"/"public" optional)
- `use_test()` -> creates a associated test file for the currently open R-file for unit testing
- `use_github_action_check_standard()` & friends -> adds infrastructure for GitHub Actions to perform R CMD check on various platforms on push/PR to default branch
- `use_vignette()` -> creates a new Rmd-vignette file
- `use_pkgdown_github_pages()` -> Sets up automatic deployment of customizable `{pkgdown}`-page via GitHub Actions
- ...
]

---

# Classes

The following slides are largely following: https://adv-r.hadley.nz/oo.html

When developing R packages it might be useful to create a new OOP class in order to tackle certain problems.

In general it could make sense to introduce a new class if:
- We want to deal with objects which are a certain subset of another class or base type.
- We are dealing with data for which certain rules apply and we want to exploit the associated possibilities.

---

# Classes

The most important OOP systems in R - since most widely used - are: S3, S4 and R6.

S3 and S4 come with base R and are **functional** OOP systems: generic functions with methods for different classes. Method calls look like normal functions: `generic(object, arg2, arg3)`.

R6 come with the package {R6} and is an **encapsulated** OOP system: methods are part of the object, with method calls often looking like `object.method(arg1, arg2)`.

---

# Classes

- S3: informal implementation of functional OOP and relies on common conventions more than guarantees
- S4: is a formal and rigorous rewrite of S3; provides more guarantees and greater encapsulation
- R6: implements the encapsulated system, widely used in other programming languages; in contrast to other R objects, R6-objects are modified in place.

---

# Classes: Base types

All classes are in the end based on the base types that come with R.

These are examples of base types (do NOT possess an attribute `class` & `is.object(x)` is `FALSE`):

`NULL`, `logical`, `integer`, `double`, `complex`, `character`, `list`, `raw`

Every object has a(n underlying) base type, can be checked with `typeof()`.

---

# Classes: S3

.font17[
Resources: 
- https://adv-r.hadley.nz/s3.html

S3 is the most commonly found class on CRAN. It's the only OO system used in the base and stats packages.

An S3 object is a base type with - at least - a `class` attribute.

If the object `x` is NOT of a base type, the S3 class is the answer to the call `class(x)`.
]

---

# Classes: S3

.font17[
Take for example a factor:
```{r}
f <- factor(c("a", "b", "c"))

typeof(f)
attributes(f)
```

`unclass()` strips away the attribute class:
```{r}
unclass(f)
```
]

---

# Classes: S3

.font17[
When a generic function is used on a S3 class, the result can differ from using it on the underlying base type, e.g.
```{r}
# check function type:
sloop::ftype(print)
print(f)
```

Mind, that a generic function has a defined interface - i.e. available arguments - that needs to be the same for all method implementations.

You can check the source code for a method implementation of a generic by calling e.g.
```{r eval=FALSE}
print.factor
# or better, cause it will work even if S3 method isn't exported:
sloop::s3_get_method(print.factor)
```
]

.font14[
Link to package {sloop} for examining OOP objects: https://sloop.r-lib.org/
]

---

# Classes: S3

.font17[How to define a new S3 class?

You do not have to explicitly define/export a class.
You set an attribute `class` with the name of the new class, that's all, e.g.:
```{r}
create_new_class <- function(x) {structure(x, class = c("new_class", class(x)))}
class(create_new_class(1))
class(create_new_class("1"))
# alternatively:
new_obj <- "test"
class(new_obj) <- "new_class"
class(new_obj)
```
]

---

# Classes: S3

.font17[
You can perform a check if an object is a member of a class (child or on of the parent classes) with `inherits(x, "<class_name>")`.
```{r}
inherits(new_obj, "new_class")
inherits(new_obj, "character")
```

If you provide a user-facing new class in your package, it would be good practice to implement three functions:
- A low-level internal constructor, new_myclass(), that efficiently creates new objects with the correct structure.
- An internal validator, validate_myclass(), that performs more computationally expensive checks to ensure that the object has correct values.
- An exported user-friendly helper, myclass(), that provides a convenient way for others to create objects of your class.
]

---

# Classes: S3

Creating a new generic:
```{r}
# in addition to `x` there can be more arguments
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```

Then you would add a method for one or more classes for this generic.

---

# Classes: S3

An S3 object can have more than one class.
The first class in the list is called a subclass of the following entries.

When a generic looks for a method to use for a S3 class object, a search takes place for registered methods in order of the class list.

For example, there is no specific print method for objects of class `ordered`, so it uses the print method for `factor`:
```{r}
o <- ordered("x")
sloop::s3_dispatch(print(o))
```

---

# Classes: S3

Example for implementing a new class for digits and implementing a print-method for it:
```{r}
create_digit <- function(x) {
  if (length(x) > 1 || !is.integer(x) || x < 0 || x > 9) stop("This is not a digit")
  structure(x, class = c("digit", class(x)))
}
digit <- create_digit(4L)
digit
```

---

# Classes: S3

.font17[
Print method:
```{r}
print.digit <- function(x, ...) {
  cat(paste0("Digit: ", as.character(x)))
  invisible(x)
}
digit
```

Summing up digits(?) -> might return another digit:
```{r}
sum.digit <- function(..., na.rm = FALSE) {
    x <- purrr::map_int(list(...), as.integer)
    sum_x <- sum(x, na.rm = na.rm)
    create_digit(sum_x %% 10L)
}
sum(digit, digit, digit)
```

More methods for new classes can be implemented for other generics.
]

---

# Classes: S3

.font17[
If you do not want to rely on methods, you can also use your own functions to create the same behaviour.
The caveat is that you will need to test for the object class yourself and throw an error if a "wrong" object is passed to the function.

It's good practice to choose a descriptive function name.

In our case, possibly:
]
```{r}
sum_digit_modulo_10 <- function(..., na.rm = FALSE) {
  if (any(map_lgl(list(...), ~ !inherits(.x, "digit")))) {
    stop("not all elements in `...` are of class `digit`.")
  }
  x <- purrr::map_int(list(...), as.integer)
  sum_x <- sum(x, na.rm = na.rm)
  create_digit(sum_x %% 10L)
}
sum_digit_modulo_10(digit, digit, digit)
```

---

# Classes: S4

.font17[
Resources for learning about S4, e.g.:
- https://stat.ethz.ch/R-manual/R-devel/library/methods/html/Introduction.html
- https://adv-r.hadley.nz/s4.html

S4 is widely used for the Bioconductor project, not so much on CRAN though.

"The implementation of S4 is much stricter than that of S3 and makes use of specialized functions for creating classes (`setClass()`), generics (`setGeneric()`), and methods (`setMethod()`).
Additionally, S4 provides both multiple inheritance (i.e. a class can have multiple parents) and multiple dispatch (i.e. method dispatch can use the class of multiple arguments).

An important new component of S4 is the slot, a named component of the object that is accessed using the specialised subsetting operator `@` (pronounced at). The set of slots, and their classes, forms an important part of the definition of an S4 class."

All S4-related functions live in the {methods} package, which is part of base R.
]

---

# Classes: S4

Creating a new S4 class "Person":
```{r}
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  )
)
```

Create a new object of this class with `new()`:
```{r}
john <- new("Person", name = "John Smith", age = NA_real_)
john
```

---

# Classes: S4

Check an S4 objects class with `is()` and access its slots with `@` or `slot()`:
```{r}
is(john)
john@name
slot(john, "age")
```

---

# Classes: S4

.font17[It is good practice to create accessor functions for setting and getting the values in the slots, e.g. we create a setter and getter generic for "age" using `setGeneric()`:
```{r}
setGeneric("age", function(x) standardGeneric("age"))
setGeneric("age<-", function(x, value) standardGeneric("age<-"))
```

Now we can add methods for our new class "Person" using `setMethod()`:
```{r}
setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```
]
---

# Classes: S4

.font17[
`setClass()` takes three arguments:
- The class name (convention: UpperCamelCase)
- A named character vector with the names and classes of the slots (see above). The pseudo-class `ANY` allows a slot to accept objects of any type.
- A prototype, a list of default values for each slot. Technically, the prototype is optional, but you should always provide it.

So a better implementation for "Person" would be:
```{r}
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  ), 
  prototype = list(
    name = NA_character_,
    age = NA_real_
  )
)
```
]

---

# Classes: S4

One more important argument for `setClass()` is `contains`. Here a class can be specified to inherit slots and behaviour from:
```{r}
setClass("Employee", 
  contains = "Person", 
  slots = c(
    boss = "Person"
  ),
  prototype = list(
    boss = new("Person")
  )
)

str(new("Employee"))
```

---

# Classes: S4

.font17[
In addition to checking the S4 classes, testing inheritance also works with `is()`:
```{r}
is(new("Employee"))
is(new("Employee"), "Person")
```

It's a good idea to provide a user-facing constructor for creating objects of the new class:
```{r}
Person <- function(name, age = NA) {
  age <- as.double(age)
  
  new("Person", name = name, age = age)
}
```

A validator is necessary to check more specific requirements for the slot contents.
It is checked upon creation of the object though, if the slot fields are of the specified class.
]

---

# Classes: S4

.font17[To create a new S4 generic, call `setGeneric()` with a function that calls `standardGeneric()`:
```{r}
setGeneric("myGeneric", function(x) standardGeneric("myGeneric"))
```

The argument `signature` of `setGeneric()` allows you to control the arguments that are used for method dispatch.
If signature is not supplied, all arguments (apart from ...) are used. It is occasionally useful to remove arguments from dispatch. This allows you to require that methods provide arguments like `verbose = TRUE` or `quiet = FALSE`, but they don’t take part in dispatch.
```{r}
setGeneric("myGeneric", 
  function(x, ..., verbose = TRUE) standardGeneric("myGeneric"),
  signature = "x"
)
```
]

---

# Classes: S4

You create a method for an S4 class generic with `setMethod()`:
```{r}
setMethod("myGeneric", "Person", function(x) {
  # method implementation
})
```

The second argument to `setMethod()` is called `signature` and can take multiple arguments, which turns method dispatch into a complicated issue.

In order to list all methods associated with a generic or all methods that belong to a class, use `methods("generic")` or `methods(class = "class")`.

---

# Classes: S4

.font17[
The rule for method dispatch with one argument for `signature` is the following:

- You start from the actual class supplied to the generic. If there is a method for it, it will be used.
- If there is no method for it and the class has multiple equally valid parents (**multiple inheritance**), all of them are checked for existing methods
- If 2 or more methods are then available, a warning is issued and the method for the class is chosen which comes first in the alphabet
- Generally the method is chosen with the smallest distance to the actual class

In general it is possible though to keep these cases of ambiguity rare.

If `signature` consists of e.g. 2 classes, the same process takes place for both classes of the objects that are provided to the generic
]

---

# Classes: R6

.font17[
Resources for learning about R6, e.g.:
- https://r6.r-lib.org/articles/Introduction.html
- https://adv-r.hadley.nz/r6.html

This OOP system comes with the package {R6}. It's for example used in {plumber} and {shiny}.

R6 has two special properties:
- It uses the encapsulated OOP paradigm, which means that methods belong to objects, not generics, and you call them like `object$method()`.
- R6 objects are mutable, which means that they are modified in place, and hence have reference semantics.
]

---

# Classes: R6

.font17[
```{r}
library(R6)
```

R6 only needs a single function call to create both the class and its methods: `R6::R6Class()`:
- The first argument is the classname. It’s not strictly needed, but it improves error messages and makes it possible to use R6 objects with S3 generics. By convention, R6 classes have UpperCamelCase names.
- The second argument, `public`, supplies a list of methods (functions) and fields (anything else) that make up the public interface of the object. By convention, methods and fields use snake_case. Methods can access the methods and fields of the current object via `self$`

Example:
```{r}
Accumulator <- R6Class("Accumulator", list(
  sum = 0,
  add = function(x = 1) {
    self$sum <- self$sum + x 
    invisible(self)
  })
)
```

]

---

# Classes: R6

```{r}
Accumulator
```
.font17[
You construct a new object from the class by calling the new() method. In R6, methods belong to objects, so you use $ to access new():
```{r}
x <- Accumulator$new() 
```
You can then call methods and access fields with $:
```{r}
x$add(4)
x$sum
```
]

---

# Classes: R6

.font17[
You can chain methods like so:
```{r}
x$add(10)$add(10)$sum
```
It might be more readable in the following manner:
```{r}
x$
  add(10)$
  add(10)$
  sum
```
]

---

# Classes: R6

.font17[
Two important methods that should be defined for most classes are `$initialize()` and `$print()`.

`$initialize()` overrides the default behaviour of `$new()` (e.g. here we add checks), and `$print()` allows it to customize the printed output:
```{r}
Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  },
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  }
))
```
]

---

# Classes: R6

This leads to the following behaviour:
```{r}
john <- Person$new("John", age = 40)
john
```

---

# Classes: R6

.font17[
An R6 class can inherit from another R6 class by providing the class object to the `inherit` argument:
```{r}
AccumulatorChatty <- R6Class("AccumulatorChatty", 
  inherit = Accumulator,
  public = list(
    add = function(x = 1) {
      cat("Adding ", x, "\n", sep = "")
      super$add(x = x)
    }
  )
)
x2 <- AccumulatorChatty$new()
x2$add(10)$add(1)$sum
```
Here we are referring to the method `add` of the (super-)class `Accumulator` with `super$add`.
]

---

# Classes: R6

You can inspect the class of an R6 object with `class()`:
```{r}
class(x2)
```

The methods and fields can be listed by `names()`:
```{r}
names(x2)
```


---

# Classes: R6

R6 objects are modified in place. If you want a copy of such an object you need to use the `$clone()` method:
```{r}
john_copy <- john$clone()
john_test <- john
john_test$name <- "Max"
john
john_copy
```

---

# Exercise (~10min)

Create and play with S3, S4 and R6 objects

---

# Unit testing

.font14[Wikipedia: "In computer programming, unit testing is a software testing method by which individual units of source code — sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures — are tested to determine whether they are fit for use"]

Unit tests ensure that the functions work in the way that they're supposed to:
- given input -> given output
- no warnings or errors under "normal" circumstances
- all function arguments are touched in the tests
- warns consistently
- errors consistently

---

# Unit testing

Package {testthat} (https://testthat.r-lib.org/index.html)

Examples for tests in the case of `create_digit()` and `sum_digit_modulo_10()` (these tests are actually executed in the knitting process):
```{r}
testthat::expect_identical(
  create_digit(6L),
  structure(6L, class = c("digit", "integer"))
)
testthat::expect_error(
  create_digit(6),
  "This is not a digit"
)
testthat::expect_identical(
  sum_digit_modulo_10(create_digit(6L), create_digit(9L)),
  create_digit(5L)
)
testthat::expect_error(
  sum_digit_modulo_10(6L, 9L),
  "are of class `digit`"
)
```

---

# Unit testing

One could think now, that these tests are very trivial, which is true.
A few words on why they are useful nevertheless:
- when updating the implementation of a function, it's surprisingly easy to change the behaviour in subtle - or sometimes even obvious - ways
- these tests can be run via CI (e.g. GitHub Actions) on various platforms. Once they work on all of them, you got yourself a robust implementation

---

# Unit testing

.font17[
In some situations the test approaches used above are not up to the task, e.g.:
- Text output that includes many characters like quotes and newlines that require special handling in a string.
- Output that is large, making it painful to define the reference output, and bloating the size of the test file and making it hard to navigate.
- Binary formats like plots or images, which are very difficult to describe in code: i.e. the plot looks right, the error message is useful to a human, the print method uses colour effectively.

In these cases it's recommended to employ snapshot tests (cf. https://testthat.r-lib.org/articles/snapshotting.html).
Here, all of a test's/function's output is stored in a separate file which is used to compare against the current test result.

The respective function is `testthat::expect_snapshot()`.
]

---

# Unit testing

In general the unit tests of an R package are located in a subfolder "tests/".
When using {testthat}, the actual tests are in the folder "tests/testthat" and there is a file "testthat.R" in "tests/" which is of the form
```{r eval=FALSE}
library(testthat)

testthat::test_check("{your.package}")
```
This call executes all the files in the "testthat" subfolder. This is done when calling `devtools::test()`.

Tip: For saving time when you have a lot of tests in a lot of R-files: use `devtools::test_active_file()` for only testing the currently open file (can be the file in "tests/testthat" or in the corresponding file in "R/").

---

# Unit testing

A test-file should always have a corresponding R-file and has the following structure (execution here would lead to failure):
```{r eval=FALSE}
test_that("create_digit() is working", {
  expect_identical(
    create_digit(6L),
    structure(6L, class = c("digit", "integer"))
  )
  expect_error(
    create_digit(6),
    "This is not a digit"
  )
})

test_that("sum_digit_modulo_10() is working", {
  expect_identical(
    sum_digit_modulo_10(create_digit(6L), create_digit(9L)),
    create_digit(5L)
  )
  expect_error(
    sum_digit_modulo_10(6L, 9L),
    "are of class `digit`"
  )
})
```

---

# Unit testing

.font14[
If your package is working with external resources (e.g. Web APIs), that might or might not be available during tests or may be really slow, but the thing you want to test is actually just the step after getting data from the API, you could consider using {mockr} (https://krlmlr.github.io/mockr/; README/vignette might be not up to date, better stick with example for `with_mock()`).

This package allows you to locally overwrite functions and use these "mock-functions" for your tests, e.g.:
```{r}
library(mockr)
access_resource <- function() stop("oops")
work_with_data_from_resource <- function() access_resource()
tester_func <- function() {
  with_mock(
    access_resource = function() 42,
    work_with_data_from_resource()
  )
}
try(work_with_data_from_resource())
tester_func()
```
In (other) words: you can write a small wrapper function exclusively for testing for which an internally used function is substituted.
]

---

# Unit testing

.font17[
If you want to do something in a test that has a persistent side-effect, which you would like to avoid, a helpful package is {withr} (https://withr.r-lib.org/).

It has many useful functions, one of which is `defer()`. Using this function you can "plan" an exit strategy for your tests.
If, for example, you created a schema and tables for testing inside this schema within a `test_that()`-call, you can add:
```{r eval=FALSE}
  withr::defer({
    purrr::walk(
      remote_tbl_names,
      ~ try(DBI::dbExecute(con_db, paste0("DROP TABLE ", .x)))
    )
    try(DBI::dbExecute(con_db, paste0("DROP SCHEMA ", schema_name_q)))
  })
```
This ensures that upon completing the test, the test-tables and the schema will be dropped again.
Even if using a database in a Docker container specifically created for the duration of testing the package (e.g. using GitHub Actions), it's useful to leave a clean state after each test in order to avoid interference with other tests.
]

---

# Exercise

- Create useful tests for your function in your new package
- Execute the tests using devtools::test() or "Ctrl+Shift+T"

---

# Errors and warnings

Descriptive error messages and warnings are enormously helpful for the user.
Consider the following:
- create a specific file with error- and warning-functions: this ensures consistency, if the same type of error occurs in different functions spread across the package
- create (snapshot) tests for these functions

In general it's useful to conduct a few checks on arguments in user-facing (exported) functions. E.g. inside a sequence of pipes a lot of unforeseen things can happen and this helps with debugging.

---

# Versioning

.font17[
For your users and also for yourself properly versioning your package is very helpful.
The version number is part of "DESCRIPTION".

Most often semantic versioning is used which for its releases uses a three-part version number: "Major.Minor.Patch".

Usually there is also a fourth part, which is the development version, which usually is at least 9000 (e.g. "1.0.0.9000").

The decision, how to bump the version number is based on the new features/bug fixes etc. that happened since the last release:
- A few bug fixes: Release a new patch version
- Some new functionality but nothing major: bump to the next minor version
- API overhaul, important new additions: new major version
]

---

# Versioning

.font17[
New developments should be tracked in a file "NEWS.md".

The package {fledge} (https://cynkra.github.io/fledge/index.html) can be of assistance in version tracking:
1. `fledge::bump_version()`: 
    - bumps the version according to your choice ("dev", "patch", "minor", "major")
    - it scrapes the commit messages for entries starting with a hyphen (can be best done in a merge commit of a PR as a second line in the commit message)
    - it automatically adds these messages to NEWS.md
    - it commits to GitHub
1. `fledge::unbump_version()`:
    - can still be called at this point to undo the bump
2. `fledge::finalize_version()`:
    - creates a tag "v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;" and pushes it to GitHub
]

---

# Continuous Integration (CI)

.font17[
CI makes it possible to start automated workflows that are triggered by customizable events.

Triggers are typically e.g. a git push to the main branch on the remote git repo, or a pull request to this main branch.

The triggered workflows are user-defined and can be virtually anything.
Useful examples with respect to (R) package development would include:
- Running the test suite
- Updating test coverage for the functions defined in the package
- Doing an R CMD check (potentially on several OS/using several R versions)
- Updating the package related website (e.g. created using {pkgdown})
]

---

# Continuous Integration (CI): e.g. GitHub Actions

.font17[
If your package has a remote git-repo on GitHub you have access to a host of Continuous Integration features called GitHub Actions (GHA).

Specifically for R this is a good resource to read more about the possibilities: https://orchid00.github.io/actions_sandbox/ (note: many of the {usethis}-helpers adding GHA-infrastructure to a package are now already on CRAN)

The repo in which many useful R-related Actions are implemented can be found here: https://github.com/r-lib/actions (see README)
This can be useful to check how certain details are implemented in case you want to tweak your workflow. There are also additional resources listed.

A video of a talk by Jim Hester about GHA for R: https://www.jimhester.com/talk/2020-rsc-github-actions/
]

---

# Best practices

- "Functions should do one thing only, but do it well" (at least it should be built on such functions)
<!-- you'll see if your function is too much "all over the place" while documenting its behaviour. -->
- But: wrapper functions can of course also be useful
- Comments in the code for others/your future self
- Errors with descriptive messages
- Consider writing a vignette once the package takes on shape
- Unit testing with `{testthat}`
- GitHub Actions (e.g. `R CMD check`)

---

# Further reading

- https://r-pkgs.org/index.html
- https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/
- https://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages
- Create a website for your package (e.g. on GitHub Pages): https://pkgdown.r-lib.org/index.html

Release to CRAN:

- e.g. https://r-pkgs.org/release.html
