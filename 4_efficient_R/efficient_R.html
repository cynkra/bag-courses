<!DOCTYPE html>
<html lang="english" xml:lang="english">
  <head>
    <title>BAG R-Courses</title>
    <meta charset="utf-8" />
    <meta name="author" content="Patrick &amp; Nicolas" />
    <meta name="author" content="cynkra GmbH" />
    <script src="efficient_R_files/header-attrs-2.11/header-attrs.js"></script>
    <link href="efficient_R_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="efficient_R_files/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="efficient_R_files/tile-view-0.2.6/tile-view.js"></script>
    <script src="efficient_R_files/xaringanExtra_fit-screen-0.2.6/fit-screen.js"></script>
    <link href="efficient_R_files/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script src="efficient_R_files/xaringanExtra-progressBar-0.0.1/progress-bar.js"></script>
    <link href="efficient_R_files/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <script src="efficient_R_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="efficient_R_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="efficient_R_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="efficient_R_files/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
    <link href="efficient_R_files/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# BAG R-Courses
### Patrick &amp; Nicolas
### cynkra GmbH
### March 2022

---



# What's in the box?

1. Caching / Memoization

1. BLAS/LAPACK

1. Data handling - practical considerations

1. Parallelization

1. Profiling

1. Benchmarking

---

class: center, inverse, middle

# Section - Caching / Memoization

---

## Caching / Memoization

Reuse previously computed output in subsequent calls.

R packages

- {memoise} - https://github.com/r-lib/memoise
- {R.cache} - https://github.com/HenrikBengtsson/R.cache

Useful when making repeated calls to a function with **identical parameters** and a **deterministic** outcome.

---

## Caching / Memoization

Good to know:

- Objects are cached in memory by default and eventually pruned if they exceed a certain size

- Only cache outcomes that are **deterministic**

- {memoise} allows for many cache types (S3, disk, memory)

---

## Caching / Memoization (Example)

Credit: https://github.com/r-lib/memoise

.small[

```r
library(memoise)
mean_fun &lt;- function(x) {
  Sys.sleep(1) # represents some long computation part
  mean(x)}
mean_fun &lt;- memoise(mean_fun)
```


```r
system.time(mean_fun(1:10))
```

```
##    user  system elapsed 
##   0.001   0.001   1.003
```

```r
system.time(mean_fun(1:10))
```

```
##    user  system elapsed 
##   0.001   0.000   0.000
```

```r
is.memoised(mean_fun)
```

```
## [1] TRUE
```
]

---

class: center, inverse, middle

# Section - BLAS + LAPACK

---

### BLAS + LAPACK

- BLAS: Basic Linear Algebra Subprograms
- LAPACK: Linear Algebra Package

Main libraries for *linear algebra* computations.

CRAN ships it's installers with standalone BLAS and LAPACK libraries which are well tested but often lack in terms of performance against other implementations.

.info[
‚ÑπÔ∏è To check your current BLAS/LAPACK libraries in R, execute `sessionInfo()`.
]

---

Other BLAS and LAPACK libraries:

- ATLAS (Automatically Tuned Linear Algebra Software) http://math-atlas.sourceforge.net/
- OpenBLAS - https://www.openblas.net/
- IntelMKL (only for Intel CPUs)

To link against such external libraries, R needs to be **installed from source**.
This is usually recommended for centrally managed R installations on servers or HPC clusters.

More information: https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Linear-algebra

---

class: center

**Source: https://github.com/andre-wojtowicz/blas-benchmarks**

![](fig/blas-ex-1.png)

![](fig/blas-ex-2.png)

---

class: center, inverse, middle

# Section - Data handling

---

## Data handling - practical considerations

.info[
‚òùÔ∏è Know where your data is written to
]

Writing/compressing/serializing large datasets (MB, GB) is limited by the **write speed of the underlying disk**.
Often, disks with lots of space (usually HDDs) do have a slow read/write performance.
This causes read/write/move processes to appear slow as the disk speed is the bottleneck.

The same goes for **file shares/file mounts** of pretty much **any protocol** (samba, sshfs, nfs, etc.).
The mileage varies among protocols but reading/writing to file shares will usually never be percieved as "fast".

---

## Data handling - practical considerations

.info[
üí°Ô∏è To speed things up, perform read/write operations on the local file system, preferably on SSD drives.
]

BUT: Avoid **big reoccurring write tasks on SSDs** if possible as this will (quickly) reduce a SSDs lifetime.

- If possible, try to use **databases**.
- If possible, keep things **in memory** and only write to disk when it's really needed.

---

## Data handling - practical considerations

Alternatives to R's native `saveRDS()` and `readRDS()`

- {fst} package (tabular data only): https://github.com/fstpackage/fst
- {qs} package: https://github.com/traversc/qs (Example üëáÔ∏è)

.center[
![](fig/qs-ex-1.png)
]

---

## Data handling - Exercise `flights` dataset

1. Load the `flights` dataset from the {nycflights13} package
1. Serialize it via `saveRDS()` and track the time
1. Serialize it via {fst} and track the time
1. Serialize it via {qs} and track the time
1. Serialize it via {fst} with openMP and track the time
1. Serialize it via {qs} and use the "fast" mode
1. Serialize it via {qs} and use the "fast" mode and all available cores of your machine
1. Read rows 100:200 of the `"dep_time"` column using {fst}
1. Read rows 100:200 of the `"dep_time"` column using {qs}
1. Read rows 100:200 of the `"dep_time"` column using {saveRDS}
1. (optional) execute all of the above in a dedicated benchmarking tool

---

## Data handling - practical considerations

[Apache Arrow](https://github.com/apache/arrow/)

- High-performance reading and writing of data files with multiple file formats and compression codecs, including built-in support for cloud storage
- Analyzing and manipulating bigger-than-memory data with {dplyr} verbs
- Supports various formats
  - feather
  - parquet
  - json
  - csv

---

## Data handling - Arrow exercise

Helpful instructions at: https://arrow.apache.org/docs/r/articles/dataset.html

1. Download the NYC Taxi data **for the year 2010**.
  (don't copy all data, one year takes already few minutes and is about 5GB in size)

2. List and sum the file size of the downloaded data (careful, tricky)

3. Print the overall passenger count for March

---

class: center, inverse, middle

# Section - Parallelization

---

## Parallelization

### Motivation

- Use the resources your machine provides
- Execute independent analysis parts asynchronous
- Scale up your analysis if needed

### Goal

üëâÔ∏è Get an overview of the available parallelization options in R

üëâÔ∏è Understand how to go parallel in practice

‚úãÔ∏è Avoid common pitfalls

---

### Available libraries

**R base**

- {parallel} package

**Community**

- {future} framework
  - {future.callr}
  - {doFuture}
  - {future.apply}
  - {future.batchtools}
  - {furrr}

- {foreach} package

---

### Iteration concepts

.pull-left[

Two main iteration concepts exist in R:

- for-loops
- The apply-family

]

.pull-right[

Two main parallel execution concepts exist in R:

- socket-based (PSOCK) (default)
- Forking (UNIX only)

]

üí°Ô∏è Parallelization packages combine the **iteration concepts** (left) with the **parallel concepts** (right) to allow for parallelized execution with minimal code adaptions compared to sequential execution.

---

## Other parallelization frameworks

Mainly for High-Performance-Computing (HPC) jobs.
Usually requires third-party tools.

- [MPI](https://en.wikipedia.org/wiki/Message_Passing_Interface) (R package: [{Rmpi}](https://cran.r-project.org/web/packages/Rmpi/index.html))
- [openMP](https://www.openmp.org/)

Interfaces to *HPC schedulers* (SLURM, LSF, TORQUE, SGE):

- ZeroMQ (R package: [{clustermq}](https://mschubert.github.io/clustermq/))

- Batchtools (R package: [{batchtools}](https://mllg.github.io/batchtools/))

---

### PSOCK vs. forking

.fl.w-50.pr2[
**PSOCK**

Creates a socket cluster of R workers which use `Rscript` to execute code
]

.fl.w-40.pa0[
**Forking**

Creates copies of the current R process.
Both parent and child process share the same memory.
]

---

### PSOCK cluster vs. forking

.fl.w-50.pr2[
**PSOCK**

.small[

‚ûïÔ∏è Available on all platforms

‚ûñÔ∏è Requires to create/copy required objects into the worker environment as the workers are not full copies of the master process

‚ûñÔ∏è Higher initialization time than forking, though since R v4 worker creation happens in parallel
]
]

.fl.w-50.pa0[
**Forking**

.small[
‚ûïÔ∏è Relatively cheap

‚ûïÔ∏è Almost no setup costs, immediate start


‚ûñÔ∏è Should/cannot be used in GUI applications (e.g. RStudio) as the forked processes will share a copy of the GUI process.
  This may lead to crashes or deadlocks

‚ûñÔ∏è Should not be used in multithreaded R processes (i.e. nested/stacked parallelization)

‚ûñÔ∏è Not available on Windows
]
]

---

### Examples

**{foreach}** - https://github.com/RevolutionAnalytics/foreach


```r
dat_list &lt;- split(iris, iris$Species)
mod_list &lt;- vector("list", length(dat_list))

for (i in seq_along(dat_list)) {
  mod_list[[i]] &lt;- lm(Sepal.Length ~ Sepal.Width +
    Petal.Length + Petal.Width, data = dat_list[[i]])
}
```

---

### Examples

**{foreach}** - https://github.com/RevolutionAnalytics/foreach

.info[
Sequential
]


```r
library(foreach)
mod_list2 &lt;- foreach(dat = dat_list) %do% {
  lm(Sepal.Length ~ Sepal.Width + Petal.Length +
    Petal.Width, data = dat)
}
```

---

### Examples

**{foreach}** - https://github.com/RevolutionAnalytics/foreach

.info[
Parallel
]

Note the `%dopar%` adaptor.


```r
library(foreach)
mod_list2 &lt;- foreach(dat = dat_list) %dopar% {
  lm(Sepal.Length ~ Sepal.Width + Petal.Length +
    Petal.Width, data = dat)
}
```

---

### Examples

**{foreach}** - Adaptors

- `%dopar%`: Native parallel adaptor from {foreach} using socket parallelization
- `%doMC%`: Custom "multicore" adaptor from {doMC}
- `%doMPI%`: Custom MPI-based parallel adaptor from {doMPI}
- `%doRNG%`: Custom parallel adaptor from {doRNG} for reproducible parallel loops
- `%doSNOW%`: Custom parallel adaptor from {doSNOW}
- `%dopar%`: via {doFuture} - a "better" version of all of the above

---

### Benefits of {doFuture}


- Takes care of exports and packages automatically

- Allows to select the backend via the cannonical {future} syntax (`plan(&lt;backend&gt;)`)

- Only one package to deal with for users

- Actively maintained

---

### apply-parallelization

**built-in**

- `parallel::mclapply()`
- `parallel::mcmapply()`
- `parallel::parApply()`
- `parallel::parLapply()`
- `parallel::parSapply()`
- `parallel::parRapply()`

**{future}**

- `{furrr}` - parallelized {purrr} using {future} internally
- Using {future} and basic `apply*` functions
- Using {future} and {future.apply}: `future_lapply()`

---

### {future}-based apply-parallelization

**{furrr}** - https://github.com/DavisVaughan/furrr

- Allows to use the {future} backend with {purrr} syntax
- {purrr} functions are prefixed with `future_`
- Go parallel with `plan(&lt;parallel plan&gt;)`

Examples:

- `map()` - `future_map()`
- `walk()` - `future_walk()`
- `imap2()` - `future_imap2()`
- etc.

---

### {future}-based apply-parallelization

**{future.apply}** - https://github.com/HenrikBengtsson/future.apply

- Similar as {furrr} but for base R `apply*` functions.
- Go parallel with `plan(&lt;parallel plan&gt;)`.

Examples:

- `lapply()` - `future_lapply()`
- `mapply()` - `future_mapply()`
- `vapply()` - `future_vapply()`
- etc.

---

### future - Exercises

.info[
  Duration: 15 mins
]

Write some code that iterates over multiple objects (e.g. in a list) and runs a few seconds.

Choose your parallel workhorse (foreach, future, apply, furrr, etc.).

Try different parallel backends (socket parallelization, forking (if possible), callr, etc.)

**What problems do you face?**
**Is something still unclear?**

---

### {future} examples

From https://future.futureverse.org/articles/future-1-overview.html#demos

Run the following code and exchange `sequential` in the `plan()` function


```r
library("future")
plan(sequential)
demo("mandelbrot", package = "future", ask = FALSE)
```

Curious what is happening under the hood? üëâÔ∏è see next slide

---

### {future} examples

Source: https://github.com/HenrikBengtsson/future/blob/develop/demo/mandelbrot.R

The following `lapply()` call is executed in parallel when a parallel `plan()` (e.g. `plan(multisession)`) is applied.


```r
lapply(seq_along(Cs), FUN=function(ii) {
  future({
    message(sprintf("Calculating tile #%d of %d ...", ii, n))
    fit &lt;- mandelbrot(C)
  })
}
```

---

### {future} examples

Available {future} backends:

- `sequential`
- `multisession` (= socket parallelization)
- `multicore` (= forking parallelization)
- `callr` (via {future.callr}) (possibly &gt;&gt; multisession)
- `batchtools`

---

## Parallelization - Putting it all together

**Do you like for-loops?**

 ‚û°Ô∏è {foreach} + {doFuture} + `%doRNG%` adaptor for reproducibility (optional)

**Do you like the apply family?**

Do you like {purrr}? ‚û°Ô∏è {furrr} or {future}

Do you favor the classical apply functions? ‚û°Ô∏è `future()` + `lapply()` &amp; friends or `future_*apply()` via {future.apply}

---


class: center, inverse, middle

# Section - Profiling

---

### Profiling

**Profiling** aims to unravel code parts with respect to

  - execution time
  - memory consumption

This can help to optimize code and reduce runtime and resource usage.

---

### Profiling - R packages

- {profvis} - https://rstudio.github.io/profvis
- {proffer} - https://r-prof.github.io/proffer
- {profmem} - https://github.com/HenrikBengtsson/profmem

and more, see https://cran.r-project.org/web/views/HighPerformanceComputing.html.

---

### Profiling - Example

Taken from https://github.com/r-prof/proffer

Note: Your timing result will depend on your respective hardware.


```r
system.time({
  n &lt;- 1e5
  x &lt;- data.frame(x = rnorm(n), y = rnorm(n))
  for (i in seq_len(n)) {
    x[i, ] &lt;- x[i, ] + 1
  }
  x
})

##    user  system elapsed
##  52.205   9.026  61.745
```

---

### Profiling - Example (slow)


```r
library(proffer)
px &lt;- pprof({
  n &lt;- 1e5
  x &lt;- data.frame(x = rnorm(n), y = rnorm(n))
  for (i in seq_len(n)) {
    x[i, ] &lt;- x[i, ] + 1
  }
  x
})
```

.info[
‚ÑπÔ∏è Execute in an editor, e.g. RStudio or VSCode
]

---

### Profiling - Example (fast)

Avoid data.frame row assignments - use vectors directly!

```r
system.time({
  n &lt;- 1e5
  x &lt;- rnorm(n)
  y &lt;- rnorm(n)
  for (i in seq_len(n)) {
    x[i] &lt;- x[i] + 1
    y[i] &lt;- y[i] + 1
  }
  x &lt;- data.frame(x = x, y = y)
})

##    user  system elapsed
##   0.016   0.001   0.016
```

---

## Resources

**Parallelization**

- [Video: Barret Schloerke || Maximize computing resources using future_promise()](https://www.youtube.com/watch?v=3gtk8uRrrL4)
- [{future} documentation and vignettes](https://future.futureverse.org/)

**R Configuration**

- [CRAN: R admin manual](https://cran.r-project.org/doc/manuals/r-release/R-admin.html)

**General best practices**

- [Book: "Efficient R" - Colin Gillespie &amp; Robin Lovelace](https://csgillespie.github.io/efficientR)

**BLAS/LAPACK**

- [Benchmark of BLAS libraries in R](https://github.com/andre-wojtowicz/blas-benchmarks)

<style>.xe__progress-bar__container {
  top:0;
  opacity: 1;
  position:absolute;
  right:0;
  left: 0;
}
.xe__progress-bar {
  height: 0.1em;
  background-color: #0051BA;
  width: calc(var(--slide-current) / var(--slide-total) * 100%);
}
.remark-visible .xe__progress-bar {
  animation: xe__progress-bar__wipe 200ms forwards;
  animation-timing-function: cubic-bezier(.86,0,.07,1);
}
@keyframes xe__progress-bar__wipe {
  0% { width: calc(var(--slide-previous) / var(--slide-total) * 100%); }
  100% { width: calc(var(--slide-current) / var(--slide-total) * 100%); }
}</style>





```css
.remark-slide-content h1 {
  /*color: #5DA5DA;*/
  color: inherit;
  /*r blue*/
  /*color: rgb(31, 101, 183);*/

  font-weight: 600;
  font-size: 45px;
  /*text-transform: uppercase;*/
}

.remark-slide-content h2 {
  color: inherit;

  /*color: rgb(31, 101, 183);*/
  font-weight: 600;
  font-size: 30px;
}

.remark-slide-content h3 {
  color: inherit;

  /*color: #4D4D4D;*/
  font-weight: 600;
  font-size: 30px;
}

.title-slide h3 {
  color: #333 !important;
}

.remark-slide-content {
  /* default: padding: 1em 4em 1em 4em; */
  padding: 1em 2em 1em 2em;
}

.small {
  font-size: 75%;
}

.small .remark-code {
  font-size: 85%;
}

.info {
  background-color: rgb(31 101 183);
  font-weight: 600;
  border-radius: 6px;
  padding-left: 6px;
  color: white;
  border-left: solid 12px #faa43a;
}

.code,
code {
  font-size: 0.9em;
}

.remark-slide-number {
  color: inherit;
  /* font-size: 10pt !important; */
  /* margin-bottom: -11.6px !important; */
  /* margin-right: 10px !important; */
  /* color: #333 !important; */
  opacity: 0.9 !important;
}

a {
  color: #498e33 !important;
}

```


&lt;style type="text/css"&gt;
.remark-slide-content h1 {
  /*color: #5DA5DA;*/
  color: inherit;
  /*r blue*/
  /*color: rgb(31, 101, 183);*/

  font-weight: 600;
  font-size: 45px;
  /*text-transform: uppercase;*/
}

.remark-slide-content h2 {
  color: inherit;

  /*color: rgb(31, 101, 183);*/
  font-weight: 600;
  font-size: 30px;
}

.remark-slide-content h3 {
  color: inherit;

  /*color: #4D4D4D;*/
  font-weight: 600;
  font-size: 30px;
}

.title-slide h3 {
  color: #333 !important;
}

.remark-slide-content {
  /* default: padding: 1em 4em 1em 4em; */
  padding: 1em 2em 1em 2em;
}

.small {
  font-size: 75%;
}

.small .remark-code {
  font-size: 85%;
}

.info {
  background-color: rgb(31 101 183);
  font-weight: 600;
  border-radius: 6px;
  padding-left: 6px;
  color: white;
  border-left: solid 12px #faa43a;
}

.code,
code {
  font-size: 0.9em;
}

.remark-slide-number {
  color: inherit;
  /* font-size: 10pt !important; */
  /* margin-bottom: -11.6px !important; */
  /* margin-right: 10px !important; */
  /* color: #333 !important; */
  opacity: 0.9 !important;
}

a {
  color: #498e33 !important;
}

&lt;/style&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": true,
"slideNumberFormat": "%current%/%total%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
